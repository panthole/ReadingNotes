##编写高质量代码：改善Java程序的151个建议
#####建议22 用整数类型处理货币
* 计算机中浮点数有可能是不准确的
* 使用BigDecimal
* 使用整型。把参数运算的值扩大100倍，并转变为整型，然后在展现时再缩小100倍

#####建议23 不要让整型默默转换
* Java是先运算然后再进行类型转换的 long = int * int 是错误的
* 如果期望的结果是long型，就让第一个参与运算的参数也是long型（1L） long = 1L * int * int

#####建议24 int类型注意边界检测
* int类型的最大值是2147483647
* 如果超出int最大值会变为负数，这导致判断出错，比如10<100,max_int+10<100
* 如果一个方法接收的是int类型的参数，那一下三个值是必测的：0、正最大、负最小，其中正最大和负最小是边界值

#####建议25 不要让四舍五入亏了一方
* 在银行交易等需要高精度数字的行业，如果采用四舍五入则每10笔的利息计算损失0.0005元。可以采用**四舍六入五**考虑，五后非零就进一，五后为零看奇偶，五前为偶应舍去，五前为奇要进一。
* 根据不同的场景，慎重选择不同的舍入模式，以提高项目的精准度，减少算法损失。

#####建议26 提防包装类型的null值
* Java引入包装类型是为了解决基本类型的实例化问题
* 如果包装类型为null，取包装类型的intValue会导致报NPE
* 包装对象和拆箱对象可以自由转换，但是要剔除null值，null值并不能转化为基本类型
* 包装类型参与运算时，要做null值校验

#####建议27 谨慎包装类型的大小
* 例如Integer包装类型，是根据其intValue()方法的返回值（也就是其相应的基本类型）进行比较的（其他的包装类型是根据相应的value值来比较的，如doubleValue、floatValue等）
* 包装类型的本身比较可以使用compareTo方法

#####建议28 优先使用整型池
* 类型装箱是通过valueOf方法实现的，通过包装类的valueOf生成包装实例可以显著提高空间和时间性能
* 在判断对象是否相等的时候，最好是用equals方法，避免用“==”产生非预期结果
* 在valueOf方法中，如果是在-128到127之间的int类型转换为integer对象，则直接从整形池中获得的，不管你输入多少次127这个数字，获得的对象都是同一个，那地址当然都是相等的。而128、555超出整型池范围，是通过new产生一个新的对象地址不同。

#####建议29 优先选择基本类型
* 编译器会自动把int类型加宽，并将其转变为long型，然后再转变为Long对象，但不能直接转变为包装类型，注意这里指的都是自动切换，而不是通过构造函数生成
* Integer和int是可以互相转换的
* f(Integer.valueOf(i))执行过程：i通过valueOf方法包装成一个Integer对象。由于没有f(Integer i)方法，编译器“聪明”地把Integer对象转换成int。int自动拓宽为long,编译结束。
* 优先选择基本类型

#####建议30 不要随便设置随机种子
* 在JAVA中随机数的产生取决于种子，遵循以下两个规则：
 * 种子不同，产生不同的随机数
 * 种子相同，即使**实例不同**也产生**相同的随机数**
* 若非必要，不要设置随机数种子
* Java中有两种方法获得不同的随机数，两者没有差别：
 *　通过java.util.Random类获得随机数的
 *　通过Math.random类获得随机数的
 
#####建议31 在接口中不要存在实现代码
##### 如下写法不好
	public class Client{
		public static void main(String[] args){
			B.s.doSomething();
		}
	}

	interface B{
		public static final S s = new S(){
			@Override
			public void doSomething(){
			}
		}
	}

	interface S{
		public void doSomething();
	}
* 接口中不能存在实现代码

#####建议32 静态变量一定要先声明后赋值
##### 如下写法不好
	public class Client{
		static{
			i=100;
		}
		public static int i =1;
		public static void main(String args[]){
			System.out.print(i);
		}
	}
* 静态变量是在类初始化时首先被加载的，JVM会去查找类中所有的静态声明，然后分配空间，注意这时候只是完成了地址空间的分配，还没有赋值，之后JVM会根据类中静态赋值（包括静态类赋值和静态块赋值）的先后顺序来执行。
* 先声明了int类型的地址空间，并把地址传递给了i,然后按照类中的先后顺序执行赋值动作，首先执行静态块中i = 100,接着执行i =1。
* 静态变量是类加载时被分配到数据区的，它在内存中只有一个拷贝，不会被分配多次，其后所有的赋值操作都是值改变，地址则保持不变。

#####建议33 静态方法不能覆写可以隐藏
* 一个实例对象有两个类型：表面类型(Apparent Type)和实际类型(Actual Type)，表面类型是声明时的类型，实际类型是对象产生时的类型。
	Base base = new Sub();//base的表面类型Base，实际类型是Sub
* 如果是通过对象调用静态方法，JVM则会通过对象的表面类型查找到静态方法的入口，继而执行
* 不要用实例对象访问静态方法或静态属性

#####建议34 尽量简化构造函数
* 构造函数不要包含抽象方法

#####建议35 避免在构造函数中初始化其他类
* 不要在构造函数中声明初始化其他类
* 比如Father是框架提供代码，Son是自己写的扩展代码，Other是框架中的拦截器（Interceptor类或者Handle类或者Hook方法），不要在拦截器中初始化Son类

#####建议36 使用构造代码块精炼程序
* Java中四种类型代码块：
  * 普通代码块：必须通过方法名调用执行
  * 静态代码块：在类中使用static修饰
  * 同步代码块：使用synchronized关键字修饰
  * 构造代码块：在类中没有任何的前缀或后缀
* 构造代码块的两个特性：在**每个构造函数中都运行**和在**构造函数中它会首先运行**
* 编译器会把构造代码块插入到每个构造函数的最顶端，构造代码块不是在构造函数之前运行的，它依托于构造函数的执行
* 构造代码块两个应用场景：
  * 初始化实例变量：每个构造函数都运行，不用在构造函数中调用方法
  * 初始化实例环境：在构造代码块中检查实例环境是否存在，不存在则创建

#####建议37 this关键字不插入构造代码
* 编译器把构造代码块插入到各个构造函数中
* 如果遇到this关键字（也就是构造函数调用自身其他的构造函数时）则不插入构造代码块
* super方法和this不一样，编译器只是把构造代码块插入到super方法之后执行

#####建议38 使用静态内部类提高封装性
* 静态内部类不持有外部类的引用：静态内部类只可以方法外部类的静态方法和静态属性
* 静态内部类不依赖外部类：外部类消亡静态内部类还是可以存在
* 普通内部类不能声明static的方法和变量：final static修饰的常量是可以的

#####建议39 初始化块是匿名函数的构造函数
	Object ob =new Object(){};
	//以上代码的含义等价于
	//定义一个继承Object的内部类
	class Sub extends Object{
	}
	//声明和赋值
	Object ob2 = new Sub();
* 在new一个对象后加上{}表示new了一个该类型的匿名函数
* 如果其中再加一个{}表示一个初始化块，起到构造函数的功能，初始化块就是构造函数块
* 多个{}表示该匿名函数中的多个构造函数块
* 匿名函数虽然没有名字，但可以有构造函数，它由构造函数块来代替

#####建议46 euqals基本原则
* equals自反性原则：对于任何非空引用x,x.equals(x)应该返回true
* equals对称性原则：对于任何引用x和y的情形，如果x.equals(y)返回true，那么y.equals(x)也应该返回true
* equals传递性原则：对于实例对象x、y、z，如果x.euqals(y)返回true,y.equals(z)返回ture,那么x.euqals(z)也应该返回true

#####建议47 覆写equals时建议使用getClass进行类型判断，而不要使用instanceof
*　覆写equals时建议使用getClass进行类型判断，而不要使用instanceof
*　如果父类在equals方法中使用了instanceof关键字，它是用来判断是否是一个类的实例对象，但是子类也会认为是该父类的实例

#####建议48 覆写equals方法必须覆写hashCode方法
* 覆写equals方法必须覆写hashCode方法
* 就是HashMap的底层处理机制是以数组的方式保存Map条目（MapEntry）的，这其中的关键是这个数组下标的处理机制：依据传入元素hashCode方法的返回值决定其数组的下标，如果该数组位置上已经有了Map条目，且与传入的键值相等则不处理，若不相等则覆盖；如果数组位置没有条目，则插入，并加入到Map条目的链表中。同理，检查键是否存在也是根据哈希码确定位置，然后遍历查找键值的。

#####建议49 推荐覆写toString方法
