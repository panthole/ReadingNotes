##编写高质量代码：改善Java程序的151个建议
#####建议22 用整数类型处理货币
* 计算机中浮点数有可能是不准确的
* 使用BigDecimal
* 使用整型。把参数运算的值扩大100倍，并转变为整型，然后在展现时再缩小100倍

#####建议23 不要让整型默默转换
* Java是先运算然后再进行类型转换的 long = int * int 是错误的
* 如果期望的结果是long型，就让第一个参与运算的参数也是long型（1L） long = 1L * int * int

#####建议24 int类型注意边界检测
* int类型的最大值是2147483647
* 如果超出int最大值会变为负数，这导致判断出错，比如10<100,max_int+10<100
* 如果一个方法接收的是int类型的参数，那一下三个值是必测的：0、正最大、负最小，其中正最大和负最小是边界值

#####建议25 不要让四舍五入亏了一方
* 在银行交易等需要高精度数字的行业，如果采用四舍五入则每10笔的利息计算损失0.0005元。可以采用**四舍六入五**考虑，五后非零就进一，五后为零看奇偶，五前为偶应舍去，五前为奇要进一。
* 根据不同的场景，慎重选择不同的舍入模式，以提高项目的精准度，减少算法损失。

#####建议26 提防包装类型的null值
* Java引入包装类型是为了解决基本类型的实例化问题
* 如果包装类型为null，取包装类型的intValue会导致报NPE
* 包装对象和拆箱对象可以自由转换，但是要剔除null值，null值并不能转化为基本类型
* 包装类型参与运算时，要做null值校验

#####建议27 谨慎包装类型的大小
* 例如Integer包装类型，是根据其intValue()方法的返回值（也就是其相应的基本类型）进行比较的（其他的包装类型是根据相应的value值来比较的，如doubleValue、floatValue等）
* 包装类型的本身比较可以使用compareTo方法

#####建议28 优先使用整型池
* 类型装箱是通过valueOf方法实现的，通过包装类的valueOf生成包装实例可以显著提高空间和时间性能
* 在判断对象是否相等的时候，最好是用equals方法，避免用“==”产生非预期结果
* 在valueOf方法中，如果是在-128到127之间的int类型转换为integer对象，则直接从整形池中获得的，不管你输入多少次127这个数字，获得的对象都是同一个，那地址当然都是相等的。而128、555超出整型池范围，是通过new产生一个新的对象地址不同。

#####建议29 优先选择基本类型
* 编译器会自动把int类型加宽，并将其转变为long型，然后再转变为Long对象，但不能直接转变为包装类型，注意这里指的都是自动切换，而不是通过构造函数生成
* Integer和int是可以互相转换的
* f(Integer.valueOf(i))执行过程：i通过valueOf方法包装成一个Integer对象。由于没有f(Integer i)方法，编译器“聪明”地把Integer对象转换成int。int自动拓宽为long,编译结束。
* 优先选择基本类型

#####建议30 不要随便设置随机种子
* 在JAVA中随机数的产生取决于种子，遵循以下两个规则：
 * 种子不同，产生不同的随机数
 * 种子相同，即使**实例不同**也产生**相同的随机数**
* 若非必要，不要设置随机数种子
* Java中有两种方法获得不同的随机数，两者没有差别：
 *　通过java.util.Random类获得随机数的
 *　通过Math.random类获得随机数的
 
#####建议31 在接口中不要存在实现代码
* 接口中不能存在实现代码

