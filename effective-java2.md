#####第14条 公有类中使用私有域和公有访问(getter)/设值(setter)方法
* 原因：public类的实例域必须私有防止外部直接访问，失去完全性
* 包私有类或私有嵌套类可以不必这样
* 不可变域，如public final类 + public final域用于只读可以接受

#####第15条 使可变性最小
* 不可变类知识其实例不能被修改的类
* 使类成为不可变
 * 1.不要提供任何改变对象属性的方法
 * 2.保证类不会被扩展
 * 3.是**所有的域都是final的**
 * 4.使所有的域都成为私有的
 * 5.确保对于任何可变组件的互斥访问
* 不可变对象本质上是线程安全的，不要求同步，可以被自由的共享，不需要进行保护性拷贝
* 不可变对象为其他对象提供了大量的构件
* 不可变类的缺点：对于每个不同的值都需要一个单独的对象，存在性能问题
* 构件不可变类的两个方法：**使类成为final的**，**私有构造器添加公有静态工厂**
* 坚决不要为每个get方法编写一个相应的set方法

#####第16条 当一个类扩展另一个类时，复合优于实现继承
* 实现继承（implementation inheritance）,当一个类扩展另一个类的时候
* 接口继承（interface inheritance）,当一个类实现一个接口的时候，或者当一个接口扩展另一个接口的时候
* 继承打破了封装性
* 原因：子类脆弱不安全，超类存在自用性方法导致不安全，超类可以获得新的方法
* 包装类可以实现于多类继承的功能
* 包装类不适合用回调框架
* 只有当子类和超类确实存在子类型关系时，使用继承才是恰当的。判断是否适合继承，一是明确两者确实存在is-a关系，每个子类确实也是父类。二是对于试图扩展的类，它的API中没有缺陷
* 如果子类覆盖了父类的方法，父类调用该方法时走子类的调用。这个可以解决父类访问子类数据的问题。
